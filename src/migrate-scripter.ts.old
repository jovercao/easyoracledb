import { Condition, Document, Select, Statement } from './ast'
import { Compiler } from './compile'
import { MigrationCommand } from './migrate-builder'
import { IndexSchema, UniqueConstraintSchema } from './schema'
import { $insert, $table, $update, and } from './sql-builder'
import { Name } from './types'

export class MigrateScripter {
  constructor(
    // public lube: Lube // public readonly commands: ReadonlyArray<MigrationCommand>
    public compiler: Compiler
  ) {}

  script(commands: ReadonlyArray<MigrationCommand>): string[] {
    const sql: string[] = [];
    for (const command of commands) {
      switch (command.operation) {
        case 'CREATE_TABLE':
          sql.push(this.createTable(command.data));
          break;
        case 'CREATE_INDEX':
          sql.push(this.createIndex(command.data.table, command.data.index));
          break;
        case 'CREATE_SEQUENCE':
          sql.push(
            this.createSequence(
              command.data.name,
              command.data.type,
              command.data.startValue,
              command.data.increment
            )
          );
          break;
        case 'DROP_TABLE':
          sql.push(this.dropTable(command.data.name));
          break;
        case 'DROP_INDEX':
          sql.push(this.dropIndex(command.data.table, command.data.name));
          break;
        case 'DROP_SEQUENCE':
          sql.push(this.dropSequence(command.data.name));
          break;
        case 'ADD_COLUMN':
          sql.push(this.addColumn(command.data.table, command.data.column));
          break;
        case 'ADD_FOREIGN_KEY':
          sql.push(
            this.addForeignKey(command.data.table, command.data.foreignKey)
          );
          break;
        case 'ADD_CHECK_CONSTRAINT':
          sql.push(
            this.addCheckConstraint(
              command.data.table,
              command.data.checkConstraint
            )
          );
          break;
        case 'ADD_UNIEQUE_CONSTRAINT':
          sql.push(
            this.addUniqueConstraint(command.data.table, command.data.uniqueConstraint)
          );
          break;
        case 'ADD_PRIMARY_KEY':
          sql.push(this.addPrimaryKey(command.data.table, command.data.columns, command.data.name))
          break;
        case 'ALTER_COLUMN':
          sql.push(this.alterColumn(command.data.table, command.data.column));
          break;
        case 'DROP_COLUMN':
          sql.push(this.dropColumn(command.data.table, command.data.name));
          break;
        case 'DROP_FOREIGN_KEY':
          sql.push(this.dropForeignKey(command.data.table, command.data.name));
          break;
        case 'DROP_CONSTRAINT':
          sql.push(
            this.dropConstraint(command.data.table, command.data.name)
          );
          break;
        case 'RENAME_TABLE':
          sql.push(this.renameTable(command.data.name, command.data.newName));
          break;
        case 'RENAME_INDEX':
          sql.push(
            this.renameIndex(
              command.data.table,
              command.data.name,
              command.data.newName
            )
          );
          break;
        case 'RENAME_COLUMN':
          sql.push(
            this.renameColumn(
              command.data.table,
              command.data.name,
              command.data.newName
            )
          );
          break;
        case 'INSERT_DATA':
          sql.push(
            this.insertData(
              command.data.table,
              command.data.rows,
              command.data.identityInsertOff
            )
          );
          break;
        case 'UPDATE_DATA':
          sql.push(
            this.updateData(
              command.data.table,
              command.data.rows,
              command.data.keyColumns
            )
          );
          break;
        case 'DELETE_DATA':
          sql.push(this.delelteData(command.data.table, command.data.where));
          break;
        case 'SQL':
          sql.push(this.sql(command.data.sql));
          break;
        case 'ANNOTATION':
          sql.push(this.annotation(command.data.message));
          break;
        case 'CREATE_VIEW':
          sql.push(this.createView(command.data.name, command.data.body));
          break;
        case 'DROP_VIEW':
          sql.push(this.dropView(command.data.name));
          break;
        case 'ALTER_VIEW':
          sql.push(this.alterView(command.data.name, command.data.body));
          break;
        case 'RESTART_SEQUENCE':
          sql.push(this.restartSequence(command.data.name));
          break;
        case 'RENAME_VIEW':
          sql.push(this.renameView(command.data.name, command.data.newName));
          break;
        case 'ALTER_TABLE':
          sql.push(this.alterTable(command.data.name, command.data.comment));
          break;
        default:
          throw new Error(`Unknow command operation.`);
      }
    }
    return sql;
  }
  addPrimaryKey(table: Name, columns: string[], name: string): string {
    throw new Error('Method not implemented.')
  }

  addUniqueConstraint(table: Name, uniqueConstraint: UniqueConstraintSchema): string;

  alterTable(name: Name, comment: string): string;

  renameView(name: Name, newName: string): string;

  restartSequence(name: Name): string;

  sql(sql: Statement | Document | string): string {
    if (typeof sql !== 'string') {
      return this.compiler.compile(sql).sql;
    }
  }

  delelteData(table: Name, where: Condition): string {
    return this.compiler.compile($delete(table).where(where)).sql;
  }

  updateData(
    table: Name,
    rows: Record<string, any>[],
    keyColumns: string[]
  ): string {
    const t = $table(table);
    const position = (row: Record<string, any>): Condition => {
      return and(keyColumns.map(key => t[key].eq(row[key])));
    };
    return rows
      .map(row =>
        this.compiler.compile($update(table).set(row).where(position(row)))
      )
      .join('\n');
  }

  insertData(
    table: Name,
    rows: Record<string, any>[],
    identityInsertOff: boolean
  ): string {
    const sql = $insert(table).values(rows);
    if (identityInsertOff) {
      sql.withIdentity();
    }
    return this.compiler.compile(sql).sql;
  }

  renameColumn(
    table: Name,
    name: string,
    newName: string
  ): string;
  renameIndex(
    table: Name,
    name: string,
    newName: string
  ): string;
  renameTable(name: Name, newName: string): string;
  dropConstraint(table: Name, name: string): string;
  dropForeignKey(table: Name, name: string): string;
  dropColumn(table: Name, name: string): string;

  annotation(message: string): string;

  alterColumn(table: Name, column: ColumnInfo): string;

  addCheckConstraint(
    table: Name,
    checkConstraint: CheckConstraintSchema
  ): string;

  addForeignKey(
    table: Name,
    foreignKey: ForeignKeySchema
  ): string;
  addColumn(table: Name, column: ColumnInfo): string;
  dropSequence(name: Name): string;
  dropIndex(table: Name, name: string): string;
  dropTable(name: Name): string;
  createSequence(
    name: Name,
    type: DbType | string,
    startValue: number,
    increment: number
  ): string;
  createTable(table: TableInfo): string;
  createIndex(table: Name, index: IndexSchema): string;
  createView(
    name: Name,
    body: string | Select,
    comment?: string
  ): string;
  alterView(
    name: Name,
    body?: string | Select,
    comment?: string
  ): string;

  dropView(name: Name): string;
}
