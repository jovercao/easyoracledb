/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  Condition,
  Parameter,
  Document,
  Identifier,
  Statement,
  Expression,
  CompatibleExpression,
  CompatibleCondition,
  CreateTable,
  AlterTable,
  CreateFunction,
  AlterFunction,
  AlterProcedure,
  AlterView,
  Annotation,
  AnnotationKind,
  Assignable,
  Assignment,
  Block,
  Case,
  CompatibleNamedSelect,
  CompatibleTable,
  CreateIndex,
  CreateProcedure,
  CreateView,
  Declare,
  Delete,
  DropFunction,
  DropIndex,
  DropProcedure,
  DropTable,
  DropView,
  Execute,
  Field,
  FieldsOf,
  Func,
  Insert,
  Procedure,
  ProxiedRowset,
  ScalarFuncInvoke,
  Select,
  SelectAction,
  TableVariantDeclare,
  Update,
  VariantDeclare,
  When,
  With,
  DeclareBuilder,
  CreateTableMemberBuilder,
  // IdentityValue
} from './ast';
import { isExpression, isScalar } from './util';
import * as std from './std';
import { RowObject, Scalar, Name } from '.';

/**
 * not 查询条件运算
 */
export const not = Condition.not;
export const $not = Condition.not;

/**
 * 使用and关联多个查询条件
 * @static
 * @param conditions 要关联的查询条件列表
 * @returns  condition
 * @memberof SQL
 */
export const and = Condition.and;
export const $and = Condition.and;

/**
 * 使用or关联多个查询条件
 * @static
 * @param conditions 要关联的查询条件列表
 * @returns  condition
 * @memberof SQL
 */
export const or = Condition.or;
export const $or = Condition.or;

/**
 * exists语句
 * @static
 * @param select
 * @returns
 * @memberof SQL
 */
export const exists = Condition.exists;
export const $exists = Condition.exists;

export const exec = Statement.execute;
export const $exec = Statement.execute;

export const execute = Statement.execute;
export const $execute = Statement.execute;

export const when = Statement.when;
export const $when = Statement.when;

export const func = Identifier.func;
export const $function = Identifier.func;

// /**
//  * 分组查询条件
//  */
// export const group = Condition.bracket;
// export const $group = Condition.bracket;

/**
 * input 参数
 */
export const input = Parameter.input;
export const $input = Parameter.input;

/**
 * output参数
 */
export const output = Parameter.output;
export const $output = Parameter.output;

/**
 * 创建一个SELECT语句
 */
export const select = Statement.select;
export const $select = Statement.select;

/**
 * 创建一个字段
 */
export const field = Identifier.field;
export const $field = Identifier.field;

/**
 * 创建一个原始的SQL片段
 * 可以插入到SQL的任意位置
 * @param sql 原始SQL
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const raw = Statement.raw;

export const $raw = raw;

/**
 * 创建一个SQL文档，包含多条SQL语句、
 * @param statements SQL语句
 */
export function doc(statements: Statement[]): Document;
export function doc(...statements: Statement[]): Document;
export function doc(...statements: Statement[] | [Statement[]]): Document {
  const lines = Array.isArray(statements[0])
    ? statements[0]
    : (statements as Statement[]);
  return new Document(lines);
}

export const $doc = doc;

/**
 * 创建一个INSERT语句
 */
export const insert = Statement.insert;
export const $insert = Statement.insert;

export const identityInsert = Statement.identityInsert;
export const $identityInsert = Statement.identityInsert;

export const $case = Statement.case;
export const $with = Statement.with;

/**
 * 创建一个UPDATE语句
 */
export const update = Statement.update;
export const $update = Statement.update;

/**
 * 内建标识符，不会被 [] 包裹，buildIn的别名
 * @param name
 */
export const builtIn = Identifier.builtIn;
export const $builtIn = Identifier.builtIn;

/**
 * 创建一个DELETE语句
 */
export const del = Statement.delete;
export const $del = Statement.delete;

/**
 * 删除语句
 */
export const $delete = Statement.delete;

/**
 * 星号
 */
export const star = Identifier.star;
export const $star = Identifier.star;

/**
 * 等效于star
 */
export const _ = Identifier.star;
export const $ = Identifier.star;

/**
 * 创建表对象，该对象是可代理的，可以直接以 . 运算符获取下一节点Identifier
 * @param name
 */
export const table = Identifier.table;

export const $table = Identifier.table;

// /**
//  * 创建一个可调用的表值函数
//  * @param names
//  */
// export function makeTableFunc<T extends RowObject,
//   A1 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1
//   ) => ProxiedRowset<T>
// export function makeTableFunc<T extends RowObject,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2
//   ) => ProxiedRowset<T>
// export function makeTableFunc<T extends RowObject,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3
//   ) => ProxiedRowset<T>
// export function makeTableFunc<T extends RowObject,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4
//   ) => ProxiedRowset<T>
// export function makeTableFunc<T extends RowObject,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression,
//   A5 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4,
//     arg5: A5
//   ) => ProxiedRowset<T>
// export function makeTableFunc<T extends RowObject>(
//   name: Name,
//   builtIn?: boolean
// ): (
//     ...args: CompatibleExpression[]
//   ) => ProxiedRowset<T>

// export function makeTableFunc<T extends RowObject>(
//   name: Name,
//   builtIn = false
// ): (
//     ...args: CompatibleExpression[]
//   ) => ProxiedRowset<T> {
//   return function (
//     ...args: CompatibleExpression[]
//   ): ProxiedRowset<T> {
//     return Statement.invokeTableFunction<T>(Identifier.func(name, builtIn), args);
//   };
// }

// /**
// * 创建一个可调用的标量函数
// * @param names
// */
// export function sfunc<T extends ScalarType,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression,
//   A5 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4,
//     arg5: A5
//   ) => Expression<T>
// export function sfunc<T extends ScalarType,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression,
//   A5 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4,
//     arg5: A5
//   ) => Expression<T>
// export function sfunc<T extends ScalarType,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression,
//   A5 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4,
//     arg5: A5
//   ) => Expression<T>
// export function sfunc<T extends ScalarType,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression,
//   A5 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4,
//     arg5: A5
//   ) => Expression<T>
// export function sfunc<T extends ScalarType,
//   A1 extends CompatibleExpression,
//   A2 extends CompatibleExpression,
//   A3 extends CompatibleExpression,
//   A4 extends CompatibleExpression,
//   A5 extends CompatibleExpression
// >(
//   name: Name,
//   builtIn?: boolean
// ): (
//     arg1: A1,
//     arg2: A2,
//     arg3: A3,
//     arg4: A4,
//     arg5: A5
//   ) => Expression<T>
// export function sfunc<T extends ScalarType>(
//   name: Name,
//   builtIn = false
// ): (...args: CompatibleExpression<ScalarType>[]) => Expression<T> {
//   return function (...args: CompatibleExpression<ScalarType>[]): Expression<T> {
//     return Statement.invokeScalarFunction<T>(
//       Identifier.func(name, builtIn),
//       args
//     );
//   };
// }

export const makeInvoke = Statement.makeInvoke;

export const proc = Identifier.proc;
export const $proc = Identifier.proc;

export const procedure = Identifier.proc;
export const $procedure = Identifier.proc;

export const makeExec = Statement.makeExec;

export const literal = Expression.literal;
export const $literal = Expression.literal;

export const val = Expression.literal;
export const $val = Expression.literal;

export const value = Expression.literal;
export const $value = Expression.literal;

export const variant = Identifier.var;
export const $variant = Identifier.var;

export const union = Statement.union;
export const $union = Statement.union;

export const unionAll = Statement.unionAll;
export const $unionAll = Statement.unionAll;

export const add = Expression.add;
export const div = Expression.div;
export const mul = Expression.mul;
export const sub = Expression.sub;
export const band = Expression.and;
export const bor = Expression.or;
export const bxor = Expression.xor;
export const shl = Expression.shl;
export const shr = Expression.shr;
export const bnot = Expression.not;
export const neg = Expression.neg;
export const mod = Expression.mod;
/**
 * 字符串连接运算
 */
export const concat = Expression.concat;

export const $add = Expression.add;
export const $div = Expression.div;
export const $mul = Expression.mul;
export const $sub = Expression.sub;
export const $bitAnd = Expression.and;
export const $bitOr = Expression.or;
export const $bitXor = Expression.xor;
export const $shl = Expression.shl;
export const $shr = Expression.shr;
export const $bitNot = Expression.not;
export const $neg = Expression.neg;
export const $mod = Expression.mod;
export const $concat = Expression.concat;

/**
 * 为表达式或者查询条件添加括号
 */
export function enclose<T extends CompatibleExpression | CompatibleCondition>(
  exprOrCondition: T
): T extends CompatibleExpression<infer S> ? Expression<S> : Condition {
  if (isScalar(exprOrCondition) || isExpression(exprOrCondition)) {
    return Expression.enclose(exprOrCondition) as any;
  }
  return Condition.enclose(exprOrCondition as CompatibleCondition) as any;
}
export const $enclose = enclose;

export const createTableMemberBuilder = CreateTable.memberBuilder;
export const alterTableAddBuilder = AlterTable.addBuilder;
export const alterTableDropBuilder = AlterTable.dropBuilder;

export interface SqlBuilder extends std.Standard {
  /**
   * 插入至表,into的别名
   * @param table
   * @param fields
   */
  insert<T extends RowObject = any>(
    table: CompatibleTable<T, string>,
    fields?: FieldsOf<T>[] | Field<Scalar, FieldsOf<T>>[]
  ): Insert<T>;

  /**
   * 插入至表,into的别名
   * @param table
   * @param fields
   */
  identityInsert<T extends RowObject = any>(
    table: CompatibleTable<T, string>,
    fields?: FieldsOf<T>[] | Field<Scalar, FieldsOf<T>>[]
  ): Insert<T>;

  /**
   * 更新一个表格
   * @param table
   */
  update<T extends RowObject = any>(
    table: CompatibleTable<T, string>
  ): Update<T>;

  /**
   * 删除一个表格
   * @param table 表格
   */
  delete<T extends RowObject = any>(
    table: CompatibleTable<T, string>
  ): Delete<T>;

  select: SelectAction;

  raw(sql: string): any;

  block(statements: Statement[]): Block;

  /**
   * 执行一个存储过程
   * @param proc
   * @param params
   */
  // execute<T extends Model> (
  //   proc: Name | Procedure<T, string>,
  //   params?: Expressions<JsConstant>[]
  // ): Execute<T>
  // execute<T extends Model> (
  //   proc: Name | Procedure<T, string>,
  //   params?: InputObject
  // ): Execute<T>
  execute<R extends Scalar = any, O extends RowObject[] = []>(
    proc: Name | Procedure<R, O, string>,
    params?: CompatibleExpression<Scalar>[]
    // | Parameter<JsConstant, string>[] | InputObject
  ): Execute<R, O>;

  invokeTableFunction<T extends RowObject = any>(
    func: Name | Func<string>,
    args: CompatibleExpression<Scalar>[]
  ): ProxiedRowset<T>;

  invokeScalarFunction<T extends Scalar = any>(
    func: Name | Func<string>,
    args: CompatibleExpression<Scalar>[]
  ): ScalarFuncInvoke<T>;

  /**
   * 赋值语句
   * @param left 左值
   * @param right 右值
   */
  assign<T extends Scalar = any>(
    left: Assignable<T>,
    right: CompatibleExpression<T>
  ): Assignment<T>;

  /**
   * 变量声明
   * @param declares 变量列表
   */
  declare(
    build: (builder: DeclareBuilder) => (VariantDeclare | TableVariantDeclare)[]
  ): Declare;

  /**
   * WHEN 语句块
   * @param expr
   * @param value
   */
  when<T extends Scalar>(
    expr: CompatibleExpression<Scalar>,
    value?: CompatibleExpression<T>
  ): When<T>;

  case<T extends Scalar>(expr?: CompatibleExpression): Case<T>;

  /**
   * With语句
   */
  with(...rowsets: CompatibleNamedSelect[]): With;
  with(rowsets: Record<string, Select>): With;
  with(...rowsets: any): With;

  union<T extends RowObject = any>(...selects: Select<T>[]): Select<T>;

  unionAll<T extends RowObject = any>(...selects: Select<T>[]): Select<T>;

  invoke<T extends RowObject>(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): () => ProxiedRowset<T>;
  invoke<T extends RowObject, A1 extends CompatibleExpression>(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1) => ProxiedRowset<T>;
  invoke<
    T extends RowObject,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression
  >(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2) => ProxiedRowset<T>;
  invoke<
    T extends RowObject,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression,
    A3 extends CompatibleExpression
  >(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2, arg3: A3) => ProxiedRowset<T>;
  invoke<
    T extends RowObject,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression,
    A3 extends CompatibleExpression,
    A4 extends CompatibleExpression
  >(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => ProxiedRowset<T>;
  invoke<
    T extends RowObject,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression,
    A3 extends CompatibleExpression,
    A4 extends CompatibleExpression,
    A5 extends CompatibleExpression
  >(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => ProxiedRowset<T>;

  invoke(
    type: 'table',
    name: Name,
    builtIn?: boolean
  ): (...args: CompatibleExpression[]) => ProxiedRowset<any>;

  invoke<T extends Scalar>(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): () => Expression<T>;
  invoke<T extends Scalar, A1 extends CompatibleExpression>(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1) => Expression<T>;
  invoke<
    T extends Scalar,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression
  >(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2) => Expression<T>;
  invoke<
    T extends Scalar,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression,
    A3 extends CompatibleExpression
  >(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2, arg3: A3) => Expression<T>;
  invoke<
    T extends Scalar,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression,
    A3 extends CompatibleExpression,
    A4 extends CompatibleExpression
  >(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Expression<T>;
  invoke<
    T extends Scalar,
    A1 extends CompatibleExpression,
    A2 extends CompatibleExpression,
    A3 extends CompatibleExpression,
    A4 extends CompatibleExpression,
    A5 extends CompatibleExpression
  >(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Expression<T>;

  invoke(
    type: 'scalar',
    name: Name,
    builtIn?: boolean
  ): (...args: CompatibleExpression[]) => Expression<any>;

  invoke(
    type: 'table' | 'scalar',
    name: Name,
    builtIn?: boolean
  ): (...args: CompatibleExpression[]) => Expression | ProxiedRowset<RowObject>;


  alterTable<N extends string>(name: Name<N>): AlterTable<N>;

  createView<T extends RowObject = any, N extends string = string>(
    name: Name<N>
  ): CreateView<T, N>;

  alterView<T extends RowObject = any, N extends string = string>(
    name: Name<N>
  ): AlterView<T, N>;

  createIndex(name: string): CreateIndex;

  createProcedure(name: string): CreateProcedure;

  alterProcedure(name: string): AlterProcedure;

  createScalarFunction(name: Name): CreateFunction;

  createTableFunction(name: Name): CreateFunction;

  alterScalarFunction(name: Name): AlterFunction;

  alterTableFunction(name: Name): AlterFunction;

  dropTable<N extends string>(name: Name<N>): DropTable<N>;

  dropView<N extends string>(name: Name<N>): DropView<N>;

  dropProcedure<N extends string>(name: Name<N>): DropProcedure<N>;

  dropFunction<N extends string>(name: Name<N>): DropFunction<N>;

  dropIndex<N extends string>(table: Name, name: N): DropIndex<N>;

  annotation(text: string, kind?: AnnotationKind): Annotation;

  readonly createTable: {
    <N extends string>(name: Name<N>): CreateTable<N>;
  } & CreateTableMemberBuilder;

  static identityValue(table: string, column: string): Expression<number> {
    return identityValue(table, column);
  }

  /**
   * 括号表达式，将表达式括起来，如优先级
   */
  static enclose<T extends Scalar>(
    value: CompatibleExpression<T>
  ): Expression<T> {
    return new ParenthesesExpression(value);
  }

  /**
   * 算术运算 +
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static neg(expr: CompatibleExpression<number>): Expression<number> {
    return new UnaryOperation(UNARY_OPERATION_OPERATOR.NEG, expr);
  }

  /**
   * 字符串连接运算
   */
  static concat(
    left: CompatibleExpression<string>,
    right: CompatibleExpression<string>
  ): Expression<string> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.CONCAT, left, right);
  }

  /**
   * 算术运算 +
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static add(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.ADD, left, right);
  }

  /**
   * 算术运算 -
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static sub(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.SUB, left, right);
  }

  /**
   * 算术运算 *
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static mul(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.MUL, left, right);
  }

  /**
   * 算术运算 /
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static div(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.DIV, left, right);
  }

  /**
   * 算术运算 %
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static mod(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.MOD, left, right);
  }

  /**
   * 位算术运算 &
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static and(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.AND, left, right);
  }

  /**
   * 位算术运算 |
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static or(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.OR, left, right);
  }

  /**
   * 位算术运算 ^
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static xor(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.XOR, left, right);
  }

  /**
   * 位算术运算 ~
   * @param value 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static not(value: CompatibleExpression<number>): Expression<number> {
    return new UnaryOperation(UNARY_OPERATION_OPERATOR.NOT, value);
  }

  /**
   * 位算术运算 <<
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static shl(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.SHL, left, right);
  }

  /**
   * 位算术运算 >>
   * @param left 左值
   * @param right 右值
   * @returns 返回算术运算表达式
   */
  static shr(
    left: CompatibleExpression<number>,
    right: CompatibleExpression<number>
  ): Expression<number> {
    return new BinaryOperation(BINARY_OPERATION_OPERATOR.SHR, left, right);
  }


  /**
   * 使用逻辑表达式联接多个条件
   */
   private static join(
    logic: LOGIC_OPERATOR.AND | LOGIC_OPERATOR.OR,
    conditions: CompatibleCondition[]
  ): Condition {
    if (conditions.length < 2) {
      throw new Error(`conditions must more than or equals 2 element.`);
    }
    return Condition.enclose(
      conditions.reduce((previous, current) => {
        let condition = ensureCondition(current);
        // 如果是二元逻辑条件运算，则将其用括号括起来，避免逻辑运算出现优先级的问题
        if (condition.$kind === CONDITION_KIND.BINARY_LOGIC) {
          condition = Condition.enclose(condition);
        }
        if (!previous) return condition;
        return new BinaryLogicCondition(logic, previous, condition);
      })
    );
  }

  /**
   * 将多个查询条件通过 AND 合并成一个大查询条件
   * @static
   * @param conditions 查询条件列表
   * @returns 返回逻辑表达式
   */
  static and(conditions: CompatibleCondition[]): Condition;
  static and(
    ...conditions: [
      CompatibleCondition,
      CompatibleCondition,
      ...CompatibleCondition[]
    ]
  ): Condition;

  static and(
    ...conditions: CompatibleCondition[] | [CompatibleCondition[]]
  ): Condition {
    if (Array.isArray(conditions[0])) {
      conditions = conditions[0];
    }
    return Condition.join(
      LOGIC_OPERATOR.AND,
      conditions as CompatibleCondition[]
    );
  }

  /**
   * 将多个查询条件通过 OR 合并成一个
   * @static
   * @param conditions 查询条件列表
   * @returns 返回逻辑表达式
   */
  static or(conditions: CompatibleCondition[]): Condition;
  static or(
    ...conditions: [
      CompatibleCondition,
      CompatibleCondition,
      ...CompatibleCondition[]
    ]
  ): Condition;

  static or(
    ...conditions: CompatibleCondition[] | [CompatibleCondition[]]
  ): Condition {
    if (Array.isArray(conditions[0])) {
      conditions = conditions[0] as CompatibleCondition[];
    }
    return Condition.join(
      LOGIC_OPERATOR.OR,
      conditions as CompatibleCondition[]
    );
  }

  /**
   * Not 逻辑运算
   * @param condition
   */
  static not(condition: Condition): Condition {
    condition = ensureCondition(condition);
    return new UnaryLogicCondition(LOGIC_OPERATOR.NOT, condition);
  }

  /**
   * 判断是否存在
   * @param select 查询语句
   */
  static exists(select: Select<any>): Condition {
    return new ExistsCondition(select);
  }

  /**
   * 比较运算 =
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static eq<T extends Scalar>(
    left: CompatibleExpression<T>,
    right: CompatibleExpression<T>
  ): Condition {
    return new BinaryCompareCondition(BINARY_COMPARE_OPERATOR.EQ, left, right);
  }

  /**
   * 比较运算 <>
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static neq<T extends Scalar>(
    left: CompatibleExpression<T>,
    right: CompatibleExpression<T>
  ): Condition {
    return new BinaryCompareCondition(BINARY_COMPARE_OPERATOR.NEQ, left, right);
  }

  /**
   * 比较运算 <
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static lt<T extends Scalar>(
    left: CompatibleExpression<T>,
    right: CompatibleExpression<T>
  ): Condition {
    return new BinaryCompareCondition(BINARY_COMPARE_OPERATOR.LT, left, right);
  }

  /**
   * 比较运算 <=
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static lte<T extends Scalar>(
    left: CompatibleExpression<T>,
    right: CompatibleExpression<T>
  ): Condition {
    return new BinaryCompareCondition(BINARY_COMPARE_OPERATOR.LTE, left, right);
  }

  /**
   * 比较运算 >
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static gt<T extends Scalar>(
    left: CompatibleExpression<T>,
    right: CompatibleExpression<T>
  ): Condition {
    return new BinaryCompareCondition(BINARY_COMPARE_OPERATOR.GT, left, right);
  }

  /**
   * 比较运算 >=
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static gte<T extends Scalar>(
    left: CompatibleExpression<T>,
    right: CompatibleExpression<T>
  ): Condition {
    return new BinaryCompareCondition(BINARY_COMPARE_OPERATOR.GTE, left, right);
  }

  /**
   * 比较运算 LIKE
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static like(
    left: CompatibleExpression<string>,
    right: CompatibleExpression<string>
  ): Condition {
    return new BinaryCompareCondition(
      BINARY_COMPARE_OPERATOR.LIKE,
      left,
      right
    );
  }

  /**
   * 比较运算 NOT LIKE
   * @param left 左值
   * @param right 右值
   * @returns 返回比较运算对比条件
   */
  static notLike(
    left: CompatibleExpression<string>,
    right: CompatibleExpression<string>
  ): Condition {
    return new BinaryCompareCondition(
      BINARY_COMPARE_OPERATOR.NOT_LIKE,
      left,
      right
    );
  }

  /**
   * 比较运算 IN
   * @param left 左值
   * @param values 要比较的值列表
   * @returns 返回比较运算对比条件
   */
  static in<T extends Scalar>(
    left: CompatibleExpression<T>,
    select: Select<any>
  ): Condition;
  static in<T extends Scalar>(
    left: CompatibleExpression<T>,
    values: CompatibleExpression<T>[]
  ): Condition;
  static in<T extends Scalar>(
    left: CompatibleExpression<T>,
    values: CompatibleExpression<T>[] | Select<any>
  ): Condition {
    return new BinaryCompareCondition(
      BINARY_COMPARE_OPERATOR.IN,
      left,
      isSelect(values) ? values.asValue() : values.map(v => ensureExpression(v))
    );
  }

  /**
   * 比较运算 NOT IN
   * @param left 左值
   * @param values 要比较的值列表
   * @returns 返回比较运算对比条件
   */
  static notIn<T extends Scalar>(
    left: CompatibleExpression<T>,
    values: CompatibleExpression<T>[]
  ): Condition {
    return new BinaryCompareCondition(
      BINARY_COMPARE_OPERATOR.NOT_IN,
      left,
      values.map(v => ensureExpression(v))
    );
  }

  /**
   * 比较运算 IS NULL
   * @returns 返回比较运算符
   * @param expr 表达式
   */
  static isNull(expr: CompatibleExpression<Scalar>): Condition {
    return new UnaryCompareCondition(UNARY_COMPARE_OPERATOR.IS_NULL, expr);
  }

  /**
   * 比较运算 IS NOT NULL
   * @param expr 表达式
   * @returns 返回比较运算符
   */
  static isNotNull(expr: CompatibleExpression<Scalar>): Condition {
    return new UnaryCompareCondition(UNARY_COMPARE_OPERATOR.IS_NOT_NULL, expr);
  }

  /**
   * 将查询条件用括号包括
   * @param condition 查询条件
   */
  static enclose(condition: CompatibleCondition<any>): Condition {
    return new ParenthesesCondition(condition);
  }

  static literal<T extends Scalar>(value: T): Literal<T> {
    return new Literal(value);
  }


  /**
   * 创建表对象，该对象是可代理的，可以直接以 . 运算符获取下一节点Identifier
   * @param name
   */
   static table<T extends RowObject = any>(
    modelCtr: ModelClass<T>
  ): ProxiedTable<T, string>;
  static table<
    T extends RowObject = DefaultRowObject,
    N extends string = string
  >(name: Name<N>): ProxiedTable<T, N>;
  static table<T extends RowObject = DefaultRowObject>(
    nameOrModel: Name | ModelClass<T>
  ): ProxiedTable<T, string> {
    if (typeof nameOrModel === 'function') {
      return makeProxiedRowset(new Table<T, string>(nameOrModel.name));
    }
    return makeProxiedRowset(new Table<T, string>(nameOrModel));
  }

  /**
   * 声明一个函数
   */
  static func<N extends string>(name: Name<N>, builtIn = false): Func<N> {
    return new Func(name, builtIn);
  }

  /**
   * 创建一个可供调用的存储过程函数
   */
  static proc<
    R extends Scalar = number,
    O extends RowObject[] = never,
    N extends string = string
  >(name: Name<N>, buildIn = false): Procedure<R, O, N> {
    return new Procedure<R, O, N>(name, buildIn);
  }

  /**
   * 创建一个字段
   */
  static field<T extends Scalar, N extends string>(name: Name<N>): Field<T, N> {
    return new Field(name);
  }

  static builtIn<T extends string>(name: T): BuiltIn<T> {
    return new BuiltIn(name);
  }

  static var<T extends Scalar, N extends string = string>(
    name: N
  ): Variant<T, N> {
    return new Variant(name);
  }

  static get star(): Star<any> {
    return new Star<any>();
  }


  /**
   * input 参数
   */
   static input<T extends Scalar, N extends string>(
    name: N,
    value: T,
    type?: DbTypeOf<T>
  ): Parameter<T, N> {
    return new Parameter(name, type, value, PARAMETER_DIRECTION.INPUT);
  }

  /**
   * output参数
   */
  static output<T extends DbType, N extends string>(
    name: N,
    type: T,
    value?: TsTypeOf<T>
  ): Parameter<TsTypeOf<T>, N> {
    return new Parameter(name, type, value, PARAMETER_DIRECTION.OUTPUT);
  }
}

export const sqlBuilder: SqlBuilder = {
  insert: Statement.insert,
  identityInsert: Statement.identityInsert,
  update: Statement.update,
  delete: Statement.delete,
  select: Statement.select,
  raw: Statement.raw,
  block: Statement.block,
  execute: Statement.execute,
  invokeTableFunction: Statement.invokeTableFunction,
  invokeScalarFunction: Statement.invokeScalarFunction,
  assign: Statement.assign,
  declare: Statement.declare,
  when: Statement.when,
  case: Statement.case,
  with: Statement.with,
  union: Statement.union,
  unionAll: Statement.unionAll,
  invoke: Statement.invoke,
  createTable: Statement.createTable,
  alterTable: Statement.alterTable,
  createView: Statement.createView,
  alterView: Statement.alterView,
  createIndex: Statement.createIndex,
  createProcedure: Statement.createProcedure,
  alterProcedure: Statement.alterProcedure,
  createScalarFunction: Statement.createScalarFunction,
  createTableFunction: Statement.createTableFunction,
  alterScalarFunction: Statement.alterScalarFunction,
  alterTableFunction: Statement.alterTableFunction,
  dropTable: Statement.dropTable,
  dropView: Statement.dropView,
  dropProcedure: Statement.dropProcedure,
  dropFunction: Statement.dropFunction,
  dropIndex: Statement.dropIndex,
  annotation: Statement.annotation,
  ...std.std,
};

export * from './std';

export default sqlBuilder;
